//*****************************************************************************
// Filename : 'expr.c'
// Title    : Expression evaluator for emuchron emulator
//*****************************************************************************

// Everything we need for running this thing in Linux
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>

// Monochron and emuchron defines
#include "../global.h"
#include "varutil.h"
#include "expr.h"

// The expression evaluator is generated by bison/flex using expr.y and expr.l.
// The generated c source code is then inserted below using #include's and
// built using standard makefile dependency rules.
#include "expr.tab.c"
#include "expr.yy.c"

//
// Function: exprEvaluate
//
// The entry point to the generated flex/bison expression evaluator.
//
// Return values:
// CMD_RET_OK		- Successful evalution of expression
// CMD_RET_ERROR	- Error in evaluation of expression
//
// Details of the evaluation are returned in the argInfo structure.
//
u08 exprEvaluate(char *argName, argInfo_t *argInfo)
{
  struct yy_buffer_state *buf;
  int parseResult;

  // Uncomment this to get bison runtime trace output.
  // This requires the bison compiler to use the --debug option.
  // For this, uncomment flag BDEBUG in MakefileEmu [firmware].
  // Keep the code section below and that build flag in sync.
  //extern int yydebug;
  //yydebug = 1;

  // If this expression was already evaluated and considered to be a constant
  // value expression we're done as the result is already available
  if (argInfo->exprConst == MC_TRUE)
    return CMD_RET_OK;

  // Init evaluation result properties
  varStatus = VAR_OK;
  exprAssign = MC_FALSE;
  exprConst = MC_TRUE;

  // Scan and parse the expression and cleanup flex/bison
  buf = yy_scan_string(argInfo->arg);
  parseResult = yyparse();
  yy_delete_buffer(buf);

  // Handle all kinds of erroneous end result situations
  if (varStatus == VAR_NOTINUSE)
  {
    // Inactive variable
    printf("%s? parse error: %s", argName, argInfo->arg);
    return CMD_RET_ERROR;
  }
  else if (varStatus == VAR_OVERFLOW)
  {
    // Variable bucket overflow
    printf("%s? internal: bucket overflow\n", argName);
    return CMD_RET_ERROR;
  }
  else if (parseResult == 1)
  {
    // Error occured in scanning/parsing the expression string
    printf("%s? syntax error: %s", argName, argInfo->arg);
    return CMD_RET_ERROR;
  }
  else if (isnan(exprValue) != 0)
  {
    // Result is not a number
    printf("%s? invalid (NaN): %s", argName, argInfo->arg);
    return CMD_RET_ERROR;
  }
  else if (isfinite(exprValue) == 0)
  {
    // Result is infinite
    printf("%s? overflow (inf): %s", argName, argInfo->arg);
    return CMD_RET_ERROR;
  }

  // Successful expression evaluation completed
  argInfo->exprAssign = exprAssign;
  argInfo->exprConst = exprConst;
  argInfo->exprValue = exprValue;

  return CMD_RET_OK;
}
