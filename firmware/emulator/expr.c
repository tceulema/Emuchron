//*****************************************************************************
// Filename : 'expr.c'
// Title    : Expression evaluator for emuchron emulator
//*****************************************************************************

// Everything we need for running this thing in Linux
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>

// Monochron and emuchron defines
#include "../global.h"
#include "varutil.h"
#include "expr.h"

// The expression evaluator is generated by bison/flex using expr.y and expr.l.
// The generated c source code is then inserted below using #include's and
// built using standard makefile dependency rules.
#include "expr.tab.c"
#include "expr.yy.c"

//
// Function: exprEvaluate
//
// The entry point to the generated flex/bison expression evaluator.
//
// Return values:
// CMD_RET_OK		- Successful evalution of expression
// CMD_RET_ERROR	- Error in evaluation of expression
//
// Details of the evaluation are returned in the argInfo structure.
//
u08 exprEvaluate(char *argName, argInfo_t *argInfo)
{
  struct yy_buffer_state *buf;
  int parseResult;

  // Uncomment this to get bison runtime trace output.
  // This requires the bison compiler to use the --debug option.
  // For this, uncomment flag BDEBUG in MakefileEmu [firmware].
  // Keep the code section below and that build flag in sync.
  //extern int yydebug;
  //yydebug = 1;

  // If this expression was already evaluated and considered to be a constant
  // value expression we're done as the result is already available
  if (argInfo->exprConst == MC_TRUE)
    return CMD_RET_OK;

  // Init evaluation result properties
  varStatus = VAR_OK;
  exprAssign = MC_FALSE;
  exprConst = MC_TRUE;

  // Scan and parse the expression and cleanup flex/bison
  buf = yy_scan_string(argInfo->arg);
  parseResult = yyparse();
  yy_delete_buffer(buf);

  // Handle all kinds of erroneous end result situations
  if (varStatus == VAR_NOTINUSE)
  {
    // Inactive variable
    printf("%s? parse error: %s", argName, argInfo->arg);
    return CMD_RET_ERROR;
  }
  else if (varStatus == VAR_OVERFLOW)
  {
    // Variable bucket overflow
    printf("%s? internal: bucket overflow\n", argName);
    return CMD_RET_ERROR;
  }
  else if (parseResult == 1)
  {
    // Error occured in scanning/parsing the expression string
    printf("%s? syntax error: %s", argName, argInfo->arg);
    return CMD_RET_ERROR;
  }
  else if (isnan(exprValue) != 0)
  {
    // Result is not a number
    printf("%s? invalid (NaN): %s", argName, argInfo->arg);
    return CMD_RET_ERROR;
  }
  else if (isfinite(exprValue) == 0)
  {
    // Result is infinite
    printf("%s? overflow (inf): %s", argName, argInfo->arg);
    return CMD_RET_ERROR;
  }

  // Successful expression evaluation completed
  argInfo->exprAssign = exprAssign;
  argInfo->exprConst = exprConst;
  argInfo->exprValue = exprValue;

  return CMD_RET_OK;
}

//
// Function: exprVarSetU08
//
// Set a variable via the expression evaluator. Yes, we can also do this
// manually via the varutil api, but the problem is that via that api we can
// assign a value to a variable name with a reserved keyword, such as 'cos'.
// And no, we can't (easily) rule out those reserved keywords via the
// command dictionary regex for a varname, as posix rexeg doesn't support
// negative lookahead constructs.
//
u08 exprVarSetU08(char *argName, char *varName, u08 value)
{
  argInfo_t argInfo;
  char *arg;
  u08 retVal;

  // Print the assignment expression, and prepare the interface towards the
  // expression evaluator
  arg = malloc(strlen(varName) + 6);
  sprintf(arg, "%s=%d\n", varName, (int)value);
  argInfo.arg = arg;
  argInfo.exprAssign = MC_FALSE;
  argInfo.exprConst = MC_FALSE;
  argInfo.exprValue = 0;

  // Evaluate the assignment expression and cleanup
  retVal = exprEvaluate(argName, &argInfo);
  free(arg);

  return retVal;
}
